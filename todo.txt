------
功能缺失
------
yield
await
async
解构赋值
拓展数组：[...[1,2,3]]
拓展对象：{ ...window.location }

可省略 super
可选参数
目录别名、文件别名

利用 that 做些什么？
	- 如指向外层 this ？
	- 虽然在箭头函数中没什么用，但对于 class 与 普通函数有用

100% 可能执行、调用的函数变量 - 2016.09.14
	- 如：fn = null, 当 fn() 代码被执行的时候，就算 fn 为 null 也不会报错
	- 可能解析前的代码，会加一个一元操作符，如：try fn()、?fn()、>>fn()、@fn()、exec fn() 等等
	- 可能解析后的代码如： (fn || Function.prototype)()
	- 原因：很多时候，callback 可以不被提供，但是每次都要判断是否存在，再去执行，很麻烦，这样做能大大简化
	- 优先级较后

解构赋值 增加“可绑定的函数”功能 - 2016.09.21
	- 如：var { ::warn, @changeStatus } = this.refs.box，当 warn()、changeStatus() 被执行时，相当于 this.refs.box.warn()、this.refs.box.changeStatus()
	- 具体符号暂定，可能使用 "@"(比较好看)、"::"(比较符合 react 习惯)
	- 原因：当一个对象的函数多次被使用，这样能大大的简化
	- 警告：不适用普通赋值，如：var ::warn = box; 这只是重命名，不是取对象属性
	- 优先级较后

类的二进制属性 - 2016.09.26
	- 如：
		class SyntaxTag {
			binary CLASS_NONE; // 0b0
			binary CLASS_STATEMENT; // 0b10
			binary CLASS_EXPRESSION | CLASS_STATEMENT; // 0b110
			binary CLASS_EXPRESSION_CONTEXT; // 0b1000
		}

	  2个二进制的连接符可以为 "|"、"&"、"^" 的任意一个

	- 原因：
	  1. 由于个人习惯上喜欢使用二进制属性
		当一个类的同一种二进制数据过多（例如事件的 type，类型很多，但某些却相互关联，如 click 与 dblclick），
		如果每次都是手动写，可能会出现失误，如： 0b1000000000 这么长，下一个就是 0b10000000000，稍微不注意，就出错了，
	  
	  2. 关系看起来更明了

	  3. 假设后续维护在中间插入一个值，不用修改后面的属性值，如，你在 100 个属性中，插入到了第二个，那么你会想要修改后面 99 个属性的值吗...

	- 区分不同种类的二进制属性，需要加区分，可以考虑如下形式：
		class SyntaxTag {
			binary class CLASS_NONE; // 0b0
			binary class CLASS_STATEMENT; // 0b10
			binary class CLASS_EXPRESSION | CLASS_STATEMENT; // 0b110
			binary class CLASS_EXPRESSION_CONTEXT; // 0b1000
			binary type TYPE_NONE; // 0b0
			binary type TYPE_MATCHABLE; // 0b10
			binary type TYPE_UNEXPECTED; // 0b100
			binary type TYPE_MISTAKABLE | TYPE_UNEXPECTED; // 0b1100
		}

	  即：binary 类型 属性名称，类型可以为任何标识符（与对象属性名一直），而且类型可以不提供

	- 注：如果并不想提供值为 0 的二进制属性，可以考虑如下形式：
		class SyntaxTag {
			binary type; // 0b0，但该属性没有名称，并不可以通过属性看得见
			binary type TYPE_MATCHABLE; // 0b10
			binary type TYPE_UNEXPECTED; // 0b100
			binary type TYPE_MISTAKABLE | TYPE_UNEXPECTED; // 0b1100
		}

	  也就是说，你的第一个二进制属性的值，是从 0b10 开始

	- 注：二进制运算，最大 32 位，而且第 32 位是判断正负，其实有效 31，不过算上 0，总共也是 32 位

	- 解析后：
		class SyntaxTag {
			get TYPE_MATCHABLE(){
				return 0b10;
			};

			get TYPE_UNEXPECTED(){
				return 0b100;
			};

			get TYPE_MISTAKABLE(){
				return 0b1100;
			};
		}

	- 同理，可以用在静态属性上，即 static binary type TYPE_MATCHABLE;

	- 优先级较后

对象属性的连续简写方式 - 2016.10.12
	- 如：
		源码：
			function getElements(){
				return jQuery(".class") <- css("color", "red"), timeStr = Date.now(), ["+1"] = 1, attr("data-key", 0);
			};

		解析后（大概意思如下）：
			function getElements(){
				var $els = jQuery(".class");

				$els.("color", "red");

				$els.timeStr = Date.now();
				$els["+1"] = 1;

				$els.attr("data-key", 0);
				return $els;
			};
		
	- 原因：
		1. 有时候，一个函数，我就想让读代码和维护代码的人一看，就知道我要返回的是什么，而不是我中间做了哪些无关紧要的事情，
		简单的说，让他人关注的是结果，而不是过程
		
		2. 如果你需要别人关注过程，那么可以不这么写，可以采取解析后的代码方式写，以上只不过提供了一种选择

	- 优先级较后

压缩打包前的开发环境不需要引用 Rexjs 等相关文件 - 2016.11.10
	- 利用 Electron 封装一个浏览器，使其内部加载 Rexjs（但不能影响当前运行环境）并利用 Rexjs 编译所有 js 文件，包括 new Function("try fn()");
	- 这样，可以使代码不用每次写完都 watch 编译，尽量使得开发环境简单

分解 rex-es.js - 2016.02.23
	- 分解成 n 个文件
	- 利用打包工具合并

--------
已完成功能 ↓
--------
对象属性默认值的表达式解析完成 及其 测试文件 - 2017.07.22

对象属性默认值的表达式验证完成 及 其他 - 2017.07.21
	- 对象属性默认值的表达式验证
		如： var obj = { a = 1 };
		效果相当于： var obj = { a: a === void 0 ? 1 : a };

	- 优化 PropertyExpression 继承关系逻辑，使其继承至 BinaryExpression，因为键值对也可以看成一种二元表达式


对象非赋值解构完成 95% 及 测试文件 95% - 2017.07.20
	- 对象嵌套数组解构
	- 数组嵌套对象解构
	- 多层互相嵌套解构
	- 及其测试文件

对象非赋值解构完成 90% 及 测试文件 90% - 2017.07.19

对象非赋值解构完成 70% - 2017.07.18
	- 简写属性 解构完成
	- 标识符键值对（及默认值）解构完成
	- 字面量键值对（及默认值）解构完成
	- 计算式键值对（及默认值）解构完成
	- 嵌套数组解构 50%

对象非赋值解构的表达式验证完成 - 2017.07.05

解析声明性质的数组解构赋值默认值 及 数组解构测试文件 - 2017.07.03

解析非声明数组解构赋值的默认值 及 数组解构测试文件 - 2017.06.28

完善数组解构 及 测试文件 - 2017.06.27
	- let 的数组解构
	- const 的数组解构
	- 空项形式的数组解构，如：var [,,,,] = [];
	- 数组验证测试文件的完成

多层数组解构完成 - 2017.06.26

简单的数组声明形式的解构 - 2017.06.20

数组非声明形式的解构表达式完成 100% - 2017.06.14
	- 数组非声明形式的解构表达式完成 100%
	- 开始数组声明形式的解构表达式 50%
	- 将所有 void function 修改为 ~function，目的是减少字符

数组非声明形式的解构表达式完成 80% - 2017.06.13

幂表达式解析完成 - 2017.05.30

将所有 null 改成 NULL，目的是让文件能压缩的更小 - 2017.05.29

对二元表达式进行重构 及 开始解析“幂表达式” - 2017.05.29
	- 二元表达式的重构：不再是一个顺序列表，而是会根据优先级进行排序算出左右侧
	- 开始解析“幂表达式”


完成后置一元操作符解析 及 其他 - 2017.05.17
	- 完成后置一元操作符解析
	- 完善一元操作符测试代码
	- 修复“带多行注释的两个独立表达式”的bug，如：a/*\n*/a
	- 增加注释测试代码

完成模块所有测试 - 2017.05.09

新增模板语法分析测试 - 2017.03.30

解决测试文件在 IE9 上面跑出的 2 个 bug - 2017.03.29
	- fn`123` 没有解析，原因是 config.template 写成了 config.base
	- 函数参数拓展符的 bug，由于 IE9 没有 "use strict" 的严格模式，即函数调用 fn() 中的 this 是指向 winodw 的，而严格模式下是 undefined

所有测试重构完成，使其能够支持 IE9 及以上的测试 - 2017.03.29

重构部分测试文件，使其能够支持 IE9 及以上的测试 - 2017.03.22
	- 完成 2/3 测试文件的重构
	- 放弃对 for(var i = 100 in {}); 表达式进行解析，因为将 var 改成 let 或 将 in 改成 of 都会报错，怀疑是不是 chrome 58 及以下的 bug

重构部分测试文件，使其能够支持 IE9 及以上的测试 - 2017.03.22
	- 完成一半测试文件的重构

完成 export 所有解析 及 其他 - 2017.03.20
	- export from 语句
	- 将所有 if、for、while、switch 条件带换行的，去除换行
	- 只差 import、 export 的测试代码

修复能在 if else 语句下使用 import、export 的 bug - 2017.03.09

完成 export class A {} 及 export function A(){} - 2017.03.09

完成 export { A as X, B as Y, C, D } 语句 - 2017.03.09

完成 export default 语句 - 2017.03.08

开始编译 export 语句 - 2017.03.07
	- 已完成对 export var、 export let、 export const 的编译

所有编译 import 都已完成 - 2017.03.02

开始编译 import 语句 - 2017.03.01
	- 已完成编译 import {} from "module-name.js"
	- 对 import 语句所在语句块做限制，只允许最外层语句块使用 import 语句

继续完成 import 部分功能 - 2017.02.27
	- import { A, B, C } from "module-name.js" 解析完成
	- 但 import { A as a } from "module-name.js" 并未完成

完成 import 部分 - 2017.02.24
	- import "module-name.js" 解析完成
	- import * as Name, defaultMember from "module-name.js"
	- 重新优化 import as 表达式的逻辑

import as 表达式基本解析完成 - 2017.02.22

import 默认输出完成 及 模块的引入功能完成 - 2017.02.22
	- import 默认输出，即：import a from "a.js"
	- 模块的引入功能完成，即：new Rexjs.Module("a.js");

修复bug 及 其他 - 2017.02.07
	- 修复bug：子类构造函数没有调用 super 却不报错的 bug
	- 完成 super 测试代码

完成类的解析、类的部分测试 及 其他 - 2017.01.20
	- 类的 ES6 版本全功能解析
	- 类的测试代码，除 super 的错误测试之外
	- 细化 DotAccessorTag，分离出 DotTag，用于解决与数字标签的异常捕获问题（标签优先级问题）
	- BlockOuterStatement 更名为 BlockComponentStatement
	- 属性方法名标签从类的分离至对象，因为类的 get、set 访问器也需要用到
	- 细化 IllegalTags 与 ECMAScriptTags 的差异，并针对优化代码，详细区别见 note.md

优化 OpenBlockTag 类 并 开始解析 super - 2017.01.13
	- OpenBlockTag 类，新增 in 方法，用于初始化当前语句块
	- 根据上一条，优化其他基于该类的子类
	- 开始解析 super

类的基本解析 90% - 2017.01.11
	- 类的基本解析 90%，除 super 之外，基本都已完成

类的基本解析 70% 及 其他 - 2017.01.10
	- 类的基本解析70%
	- 修复 windows 换行符 \r\n 与 mac 换行符 \n 区别的 bug
	- 修复对象属性访问器 bug，如 !{ get1: 1 }，之前是会报错的

开始解析类 及 其他 - 2017.01.05
	- 开始解析类
	- Statement 类新增 tagOf、bindingOf 两方法，并根据此两方法优化全文件代码
	- 修改 Object 相关的一些类的名称

二进制数解析、八进制数解析 及 其他 - 2017.01.02
	- 基本解析
	- 测试代码
	- 优化 ECMAScript6Config 类，减小代码量

函数模板参数解析 - 2016.12.29
	- 基本解析
	- 测试代码

模板功能解析 - 2016.12.27
	- 基本解析
	- 测试代码

新增 ECMAScriptOrders 类并开始解析模板 - 2016.12.26

new.target 表达式完成 及 其他 - 2016.12.26
	- 基本功能解析（只解析，但不编译，因为运行时环境上下文很难确定）
	- 测试代码
	- 将 Statements.prototype.closure 属性修改成 scope，并进行细分
	- 根据 Statements.prototype.scope 对中断流进行部分重构

修复箭头表达式 bug - 2016.12.25
	- 带语句块的箭头表达式，后面只能接逗号或语句结束
	- 完善修复该 bug 之后的测试文件

为方便二次开发重构代码 - 2016.12.24
	- 新增 ECMAScriptErrors 类，用于归类所有错误
	- SyntaxTag 类，新增属性 binding，替代独立闭包内的标签变量（因为闭包内变量可拓展性差），用于指定 try、catch 的返回值
	- 新增 ConditionalExpression 与 ConditionStatement，共用于 if、for、switch、while 等带条件的表达式

箭头函数功能全部完成 及 其他 - 2016.12.22
	- 所有箭头函数功能
	- 完整的箭头函数测试代码
	- 表达式基类 Expression，新增 compileTo，用于编译表达式使用
	- SyntaxError 的 context 参数改为 info，并支持 Expression 类型的参数
	- ECMAScriptVariableCollections 类，新增 4 个初始化方法
	- 优化 UnaryExpresion 与 BinaryExpression 判断分隔符的方式
	- 新增 FunctionBodyExpression 表达式，用于解析默认值参数

带小括号参数的箭头函数 及 其他 - 2016.12.21
	- 完成基本功能，除了重复参数名没有验证
	- 新增标识符表达式，用于区别两种不同的可赋值表达式，即 标识符表达式 与 属性访问表达式
	- ListExpression，新增参数，需要提供 context
	- 重构、优化函数参数表达式

箭头函数功能 - 2016.12.20
	- 完成基本功能，除了带小括号参数
	- 完成测试代码，除了带小括号参数

const 关键字 - 2016.12.19
	- const 关键字基本解析
	- const 关键字测试代码

let 关键字 及 其他 - 2016.12.17
	- let 关键字基本解析
	- let 关键字测试代码
	- MappingBuilder 优化
	- 函数优化：函数名、参数名 与 let 的兼容问题

拓展符 及 其他 - 2016.12.15
	- 拓展符解析
	- 拓展符测试代码
	- 根据拓展符重构函数调用
	- 重构 switch case
	- 新增变量名、变量名集合相关类，用于记录文档中所有的变量名

剩余对象功能解析 及 其他 - 2016.12.06
	- 对象简写方法
	- 对象简写计算式方法
	- 对象访问器属性
	- 对象测试文件
	- 将所有表达式上下文都设置为可能误解的
	- 完善标识符的正则，增加“关键字加数字”（即类似：var1）变量名的识别

函数表达式测试代码 - 2016.11.30

函数表达式解析完成 - 2016.11.29
	- 基本解析
	- 省略参数
	- 默认参数

解析机制完善 - 2016.11.29
	- 增加 DefaultExpression
	- 设置所有可为空的匹配组语句的表达式为 new DefaultExpression()
	- 移除所有类似 CloseEmptyBlockTag、CloseEmptyCallTag 标签

函数声明解析完成 - 2016.11.28
	- 基本解析
	- 省略参数
	- 默认参数
	- 测试代码

修复语句块内带不完整语句的bug - 2016.11.25
	- 修复了如：{ if }，会解析成功，但提取内容会失败
	- 增加标签类型，即 TagType.TYPE_ILLEGAL，供非法标签使用
	- 大部分标签列表，用 TYPE_ILLEGAL 进行整改

对象部分解析功能 - 2016.11.22
	- 数字属性名及测试代码
	- 字符串属性名及测试代码
	- 计算式属性名的解析，但并未做编译处理，目的是等简写方法一起做处理，而简写方法又需要等待函数解析完才能继续...

对象部分解析功能 - 2016.11.21
	- 空对象及测试代码
	- 标识符属性及测试代码
	- 关键字属性及测试代码
	- 简写属性名及测试代码

with 关键字标签 - 2016.11.21

反斜杠转义符 - 2016.11.21

三元运算符 - 2016.11.19
	- 基本解析
	- 测试代码

前置递增、递减运算符没有做操作对象检测 - 2016.11.16
	- 如果操作对象不是可赋值表达式(AssignableExpression)，则报错

switch 语句重构完成 - 2016.11.16
	- switch
	- case
	- default
	- switch 语句中的 break

函数调用解析完成 - 2016.11.14
	- 基本功能
	- 测试代码

try、catch、finally 语句重构完成 - 2016.11.14

中断流语句重构完成 - 2016.11.14
	- break 语句
	- continue 语句
	- return 语句
	- throw 语句

for 语句 - 2016.11.10
	- for 循环
	- for in
	- for of

重构 - 2016.09.13 ~ 2016.11.05
	- 移除临时表达式机制，即 statement.$expression
	- 完善语句的 try、catch 机制，并增加 finally 机制
	- 优化 SyntaxTag.prototype.type、SyntaxTag.prototype.class 两属性
	- 其他语句、表达式的重构

var 语句 - 2016.09.13
	- 基本功能
	- 测试代码

case 测试代码 - 2016.09.12
case 基本功能 - 2016.09.07

switch - 2016.09.06
	- 基本功能

中括号属性访问器 - 2016.09.05
	- 基本功能
	- 测试代码

点属性访问器 - 2016.08.31
	- 基本功能
	- 测试代码

数组 - 2016.08.30
	- 基本功能
	- 测试代码

完善 do while 语句 - 2016.08.29
	- do while 条件语句中禁止出现分号

完善 while 语句 - 2016.08.29
	- while 条件语句中禁止出现分号
	- 增加测试代码

完善 if 语句 - 2016.08.29
	- if 条件语句中禁止出现分号
	- 增加测试代码

重写 native 正则，但无果 - 2016.08.26
	- 由于现有的 js native 正则没有完美的满足需求（当正则中使用了小括号，性能会变慢很多很多），打算重写，但发现智商严重不够，2星期无果...
	- 后续有头绪再继续
	- 问题所在 /a{2,8}a{3,7}?a{4,5}a/

do while 语句测试代码 - 2016.08.12
do while 语句 - 2016.08.11

完善逗号 - 2016.08.10
	- 测试代码
	- 修复bug，二元表达式的支持不完善

完善二元表达式 - 2016.08.10
	- 测试代码
	- 逻辑

逗号 - 2016.08.01
	- 基本

label 标签 - 2016.07.26
	- 基本
	- 测试代码

分组小括号运算符 - 2016.07.24
	- 基本
	- 测试代码

一元运算符 - 2016.07.23
	- 增加一元运算符测试代码
	- 前置递增运算符 ++
	- 前置递减运算符 --
	- 遗留 bug，前置递增、递减运算符没有做操作对象检测

增加变量解析测试 - 2016-07.21
增加字符串解析测试 - 2016.07.21
增加正则表达式解析测试 - 2016.07.21

完善数字解析 - 2016.07.20
	- 增加测试代码，并根据测试代码修复以下 bug
	- 修复 bug1 不支持带点的整数
	- 修复 bug2 不支持省略加号的整数正指数幂
	- 修复 bug3 不支持整数指数幂
	- 修复 bug4 不支持带点的整数指数幂

简单测试 - 2016.07.20
	- 结果为真的测试
	- 结果为假的测试

一元运算符 - 2016.07.19
	- +
	- -
	- !
	- ~
	- delete
	- new
	- typeof
	- void

重构逻辑 - 2016.07.19
	- 增加 statement.$expression 记录临时的表达式，主要供不确定性及不完整的表达式使用，待表达式完整后，再设置到 statement.expression 属性上
	- 去掉 expression.end 方法与 expression.endWith 方法

return - 2016.07.14
try、catch、finally - 2016.07.13
	- try

对文件起始（FileStartTag）、文件结束（FileEndTag）进行处理 - 2016.07.09
	- FileStartTag 标签作用于添加 "void function(){" 头部代码
	- FileEndTag 标签作用于添加 "}();" 尾部代码

增加 sourceURL 及 sourceMappingURL 功能 - 2016.07.08

修复字符串bug - 2016.07.04
	- 修复 bug1 不支持多反斜杠
	- 修复 bug2 支持反斜杠加换行符进行换行

报错功能 - 2016.07.04
	- 能定位到指定文件指定行数

增加行数和列数 - 2016.07.03

未捕获的行结束符标签 - 2016.07.02
	- 某些语句不支持换行而且也不支持带换行的注释，如 throw 语句等

拆分注释 - 2016.07.02
	- 拆分为 3 部分：起始 - 内容 - 结束，
	- 目的是捕获其中的换行符。

continue - 2016.06.30
break - 2016.06.30
while - 2016.06.29
debugger - 2016.06.27
throw - 2016.06.27
if - 2016.06.26
false - 2016.06.26
else - 2016.06.26
in - 2016.06.26
instanceof - 2016.06.26
null - 2016.06.26
this - 2016.06.26
true - 2016.06.26
语句块 - 2016.06.26
分号 - 2016.06.26
换行符 - 2016.06.26
注释 - 2016.06.26
正则表达式 - 2016.06.26
数字 - 2016.06.26
变量 - 2016.06.26
字符串 - 2016.06.26
二元运算符 - 2016.06.26