import { ConditionalExpression } from "../base-expression/conditional.expr";
import { ECMAScriptConfig } from "../ecmascript/ecmascript-config";
import { ContentBuilder }, Rexjs from "../core";

export let ForExpression = function(compileOf, compileIteratorWithGenerator, compileWithGenerator){
	/**
	 * for 表达式
	 * @param {Context} context - 语法标签上下文
	 * @param {Statements} statements - 当前语句块
	 */
	return class ForExpression extends ConditionalExpression {
		/**
		 * 主体表达式
		 * @type {Expression}
		 */
		body = null;

		/**
		 * 迭代符
		 * @type {String}
		 */
		iterator = "";

		/**
		 * 临时变量名
		 * @type {String}
		 */
		variable = "";

		/**
		 * 以生成器形式的提取表达式文本内容
		 * @param {ContentBuilder} contentBuilder - 内容生成器
		 * @returns {void}
		 */
		generateTo(contentBuilder){
			let { iterator, contextGeneratorIfNeedCompile: generator } = this;

			// 如果迭代符存在
			if(iterator){
				// 如果是 of 标签而且需要编译
				if(iterator === "of" && ECMAScriptConfig.es6Base){
					// 以生成器形式编译 for of
					compileIteratorWithGenerator(this, generator, contentBuilder, false);
					return;
				}
				
				// 以生成器形式编译 for in
				compileIteratorWithGenerator(this, generator, contentBuilder, true);
				return;
			}

			// 以生成器形式编译 for in
			compileWithGenerator(this, generator, contentBuilder);
		};
		
		/**
		 * 以常规形式的提取表达式文本内容
		 * @param {ContentBuilder} contentBuilder - 内容生成器
		 * @returns {void}
		 */
		normalizeTo(contentBuilder){
			// 添加 for 关键字
			contentBuilder.appendContext(this.context);

			// 如果是 of 标签而且需要编译
			if(this.iterator === "of" && ECMAScriptConfig.es6Base){
				// 编译 for of
				compileOf(
					this.condition,
					this.body,
					contentBuilder,
					new ContentBuilder(),
					this.variable
				);
				
				return;
			}

			// 提取条件
			this.condition.extractTo(contentBuilder);
			// 提取主体
			this.body.extractTo(contentBuilder);
		};
	};
}(
	// compileOf
	(condition, body, contentBuilder, builder, variable) => {
		let { inner } = condition;

		// 追加 for 循环条件起始小括号
		contentBuilder.appendContext(condition.opening);
		// 追加 for 循环初始化语句
		contentBuilder.appendString(variable + "=new Rexjs.Generator(");

		// 追加生成器的对象
		inner.right.extractTo(contentBuilder);

		// 追加 for 循环的逻辑条件
		contentBuilder.appendString(");!" + variable + ".iterator.closed;");
		// 追加 for 循环条件结束小括号
		contentBuilder.appendContext(condition.closing);
		// 追加语句块起始大括号，目的是让 let、const 发挥效果
		contentBuilder.appendString("{");

		// 将对象值的初始化表达式提取到新的内容生成器里，目的是防止文档位置（position）的错乱，导致 mappings 不可用 
		inner.left.extractTo(builder);

		// 追加对象值的初始化
		contentBuilder.appendString(
			builder.result + "=" + variable + ".next().value;"
		);

		// 提取主体
		body.extractTo(contentBuilder);
		// 追加语句块结束小括号
		contentBuilder.appendString("}");
	},
	// compileIteratorWithGenerator
	(expression, generator, contentBuilder, isIn) => {
		let { variable, condition: { inner } } = expression, builder = new ContentBuilder();

		// 追加 for 循环初始化语句
		contentBuilder.appendString(variable + "=new Rexjs.Generator(");

		// 如果是 for in
		if(isIn){
			// 追加获取枚举属性名方法
			contentBuilder.appendString("Rexjs.Object.getEnumerablePropertyNames(");
			// 追加生成器的对象
			inner.right.extractTo(contentBuilder);
			// 追加获取枚举属性名方法的结束小括号
			contentBuilder.appendString(")");
		}
		else {
			// 追加生成器的对象
			inner.right.extractTo(contentBuilder);
		}

		// 追加 Generator 的结束小括号与语句分隔符
		contentBuilder.appendString(");");

		// 以生成器形式编译条件
		expression.generateConditionTo(
			new Rexjs.CompiledExpression("!" + variable + ".iterator.closed"),
			contentBuilder
		);

		// 将对象值的初始化表达式提取到新的内容生成器里，目的是防止文档位置（position）的错乱，导致 mappings 不可用 
		inner.left.extractTo(builder);

		// 追加对象值的初始化
		contentBuilder.appendString(
			builder.result + "=" + variable + ".next().value;"
		);

		// 以生成器形式编译主体
		expression.generateBodyTo(expression.body, contentBuilder);
	},
	// compileWithGenerator
	(expression, generator, contentBuilder) => {
		let { inner } = expression.condition, { 1: logicConditionExpression } = inner;

		// 修改索引值，以配合编译 inner[2]
		expression.adapterIndex = expression.branchFlowIndex = generator.nextIndex();

		// 提取初始化条件
		inner[0].extractTo(contentBuilder);
		// 追加分号
		contentBuilder.appendString(";");

		// 以生成器形式编译逻辑条件
		expression.generateConditionTo(
			logicConditionExpression.default ? new Rexjs.CompiledExpression("true") : logicConditionExpression,
			contentBuilder
		);

		// 提取最终条件
		inner[2].extractTo(contentBuilder);

		// 追加设置索引字符串及 case 表达式
		contentBuilder.appendString(
			";" + generator.currentIndexString + "=" + expression.conditionIndex + ";break;case " + expression.positiveIndex + ":"
		);

		// 以生成器形式编译主体
		expression.generateBodyTo(expression.body, contentBuilder);
	}
);